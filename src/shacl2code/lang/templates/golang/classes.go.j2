//{#
vim: ft=go
#} {{ disclaimer }}
//
// SPDX-License-Identifier: {{ spdx_license }}

package {{ package }}

import (
    "iter"
	"reflect"
	"time"
)

{%- set view_prefix = "as" %}
{%- set cast_prefix = "cast" %}
{%- set list_suffix = "List" %}

{%- macro set_id(class,classes,id) -%}
{%- if class.parent_ids -%}
{%- for p in class.parent_ids -%}
{{ struct_name(classes.get(p)) }}: {{ struct_name(classes.get(p)) }}{
{{- set_id(classes.get(p),classes,id) -}}
}
{%- endfor -%}
{%- else -%}
ID:"{{ id }}"
{%- endif %}
{%- endmacro -%}

{% for class in classes %}
{%- for l in class.comment.splitlines() %}
{{ ("// " + l).rstrip() }}
{%- endfor -%}

{%- set is_public = not class.is_abstract or class.is_extensible %}
type {{ struct_name(class) }} struct {
{%- if class.parent_ids %}
{%- for p in class.parent_ids %}
    {{ struct_name(classes.get(p)) }}
{%- endfor %}
{%- else %}
	ID string
{%- endif %}
{% for prop in class.properties %}
    {%- for l in prop.comment.splitlines() %}
    {{ ("// " + l).rstrip() }}
    {%- endfor %}
	{%- if prop.class_id %}
	{%- set propClass = classes.get(prop.class_id) %}
	{%- if not_enum_type(propClass,classes) %}
	{#- specialized type list #}{%- if prop_is_list(prop) %}
	{{ prop_name(prop) }} {{ struct_name(propClass) }}{{ list_suffix }}
	{#- single instance #}{%- else %}
	{{ prop_name(prop) }} {{ interface_name(propClass) }}
    {%- endif %}
	{% else %}
    {#- list structs #}{%- if prop_is_list(prop) %}
	{{ prop_name(prop) }} []{{ struct_name(propClass) }}
    {#- structs #}{%- else %}
	{{ prop_name(prop) }} {{ struct_name(propClass) }}
    {%- endif %}
    {%- endif %}
	{%- else -%}
	{#- primitive list #}{%- if prop_is_list(prop) %}
    {{ prop_name(prop) }} []{{ prop_go_type(prop, classes) }}
	{#- primitive #}{%- else %}
    {{ prop_name(prop) }} {{ prop_go_type(prop, classes) }}
    {%- endif %}
    {%- endif %}
{%- endfor %}
}
{% for member in class.named_individuals %}
{%- for l in member.comment.splitlines() %}
{{ ("// " + l).rstrip() }}
{%- endfor %}
var {{ struct_name(class) }}_{{ varname(member.varname) }} = {{ struct_name(class) }} {
{{- set_id(class,classes,member._id) -}}
}
{%- endfor %}

{% if not_enum_type(class,classes) %}
func {{ cast_prefix }}{{ struct_name(class) }}(o any) *{{ struct_name(class) }} {
	if o, ok := o.({{ interface_name(class) }}); ok {
		return o.{{ view_prefix }}{{ struct_name(class) }}()
	}
	return nil
}

func (o *{{ struct_name(class) }}) {{ view_prefix }}{{ struct_name(class) }}() *{{ struct_name(class) }} {
	return o
}

type {{ interface_name(class) }} interface {
	{%- for p in class.parent_ids %}
	{{ interface_name(classes.get(p)) }}
	{%- endfor %}
	{{ view_prefix }}{{ struct_name(class) }}() *{{ struct_name(class) }}
}

type {{ struct_name(class) }}{{ list_suffix }} []{{ interface_name(class) }}

func (o *{{ struct_name(class) }}{{ list_suffix }}) Append(values ...{{ interface_name(class) }}) { *o = append(*o, values...) }
func (o *{{ struct_name(class) }}{{ list_suffix }}) Remove(value {{ interface_name(class) }}) { remove(o, value) }
{% for child in classes %}
{%- if class == child or class_is_subclass(class,child,classes) %}
func (o *{{ struct_name(class) }}{{ list_suffix }}) {{ struct_name(child) }}Iter() iter.Seq2[{{ interface_name(class) }},*{{ struct_name(child) }}] { return typeIter(*o, {{ cast_prefix }}{{ struct_name(child) }}) }
{%- endif %}
{%- endfor %}
{%- endif %}{# named individuals #}
{%- endfor %}

type ExternalIRI struct {
	iri string
}
func NewExternalIRI(iri string) *ExternalIRI {
	return &ExternalIRI{iri: iri}
}
{% for child in classes %}
{%- if not_enum_type(child,classes) %}
func (o *ExternalIRI) {{ view_prefix }}{{ struct_name(child) }}() *{{ struct_name(child) }} { return nil }
{%- endif %}
{%- endfor %}

func {{ cast_prefix }}[T any](value any) *T {
	var t T
	switch any(t).(type) {
	{%- for class in classes %}
	{%- if not_enum_type(class,classes) %}
	case {{ struct_name(class) }}:
		if v, ok := any({{ cast_prefix }}{{ struct_name(class) }}(value)).(*T); ok { return v }
	{%- endif %}
	{%- endfor %}
	}
	panic("invalid type cast, unknown type: " + reflect.TypeOf(t).String())
}

func As[T any](value any, f func(v *T)) {
	v := {{ cast_prefix }}[T](value)
	if v != nil {
		f(v)
	}
}
