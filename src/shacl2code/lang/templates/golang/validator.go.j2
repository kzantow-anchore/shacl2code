//{#
vim: ft=go
#} {{ disclaimer }}
//
// SPDX-License-Identifier: {{ spdx_license }}

package {{ package }}

import (
	"fmt"
	"slices"
	"strconv"
	"strings"
)

type ValidationError struct {
	Path []string
	Err error
}

func (v ValidationError) String() string {
	return strings.Join(v.Path, ".") + ": " + v.Err.Error()
}

func (v ValidationError) Error() string {
	return v.String()
}

func newValidationError(path []string, err error) ValidationError {
	return ValidationError{
		Path: path,
		Err: err,
	}
}

type validator interface {
	Validate(visited map[any]struct{}, path ...string) []ValidationError
}

func validateInValues(path []string, value string, valid ...string) []ValidationError {
	if slices.Contains(valid, value) {
		return nil
	}
	return []ValidationError{newValidationError(path, fmt.Errorf("invalid value: '%v', expected: %v", value, valid))}
}

{%- set view_prefix = "as" %}
{%- set cast_prefix = "cast" %}
{%- set list_suffix = "List" %}

{% for class in classes %}

{%- set is_public = not class.is_abstract or class.is_extensible %}

func (o *{{ struct_name(class) }}) Validate(visited map[any]struct{}, path ...string) []ValidationError {
	if visited == nil { visited = map[any]struct{}{} }
	if _, ok := visited[o]; ok {
		return nil
	}
	visited[o] = struct{}{}
	var errs []ValidationError
{%- for p in class.parent_ids %}
	errs = append(errs, o.{{ struct_name(classes.get(p)) }}.Validate(visited, path...)...)
{% endfor %}
{% if class.named_individuals|length > 1 and class.properties|length < 2 %}
	errs = append(errs, validateInValues(path, o.ID,
{%- for member in class.named_individuals -%}
{{ struct_name(class) }}_{{ varname(member.varname) }}.ID,
{%- endfor -%}
	)...)
{% endif %}
{% for prop in class.properties %}
    {# list structs #}{%- if prop.class_id and prop.enum_values and prop_is_list(prop) %}
	{%- if prop.min_count is not none and prop.min_count > 0 %}
	if len(o.{{ prop_name(prop) }}) < {{ prop.min_count }} {
		errs = append(errs, newValidationError(append(path, "{{ prop_name(prop) }}"), fmt.Errorf("required min count: %v", {{ prop.min_count }})))
	}
	{%- endif %}
	{%- if prop.max_count is not none and prop.max_count > 0 %}
	if len(o.{{ prop_name(prop) }}) > {{ prop.max_count }} {
		errs = append(errs, newValidationError(append(path, "{{ prop_name(prop) }}"), fmt.Errorf("required max count: %v", {{ prop.max_count }})))
	}
	{%- endif %}
	for _, v := range o.{{ prop_name(prop) }} {
		errs = append(errs, v.Validate(visited, append(path, "{{ prop_name(prop) }}")...)...)
	}
    {# structs #}{%- elif prop.class_id and prop.enum_values %}
	{%- if prop.min_count is not none and prop.min_count > 0 %}
	if o.{{ prop_name(prop) }}.ID == "" {
		errs = append(errs, newValidationError(append(path, "{{ prop_name(prop) }}"), fmt.Errorf("required")))
	}
	{%- endif %}
	errs = append(errs, o.{{ prop_name(prop) }}.Validate(visited, append(path, "{{ prop_name(prop) }}")...)...)
	{# specialized type list #}{%- elif prop.class_id and prop_is_list(prop) %}
	for i, v := range o.{{ prop_name(prop) }} {
		if v, ok := v.(validator); ok {
			errs = append(errs, v.Validate(visited, append(path, "{{ prop_name(prop) }}", strconv.Itoa(i))...)...)
		}
	}
	{# single instance #}{%- elif prop.class_id %}
	if v, ok := o.{{ prop_name(prop) }}.(validator); ok {
		errs = append(errs, v.Validate(visited, append(path, "{{ prop_name(prop) }}")...)...)
	}
	{# primitive list #}{%- elif prop_is_list(prop) %}
	// TODO: check for required/min/max/etc.
	{# primitive #}{%- else %}
	// TODO: check for required
    {%- endif %}
{%- endfor %}
	return errs
}
{%- endfor %}
